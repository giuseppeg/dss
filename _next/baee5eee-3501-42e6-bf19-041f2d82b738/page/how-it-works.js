module.exports=__NEXT_REGISTER_PAGE("/how-it-works",function(){return{page:webpackJsonp([7],{253:function(e,a,n){e.exports=n(254)},254:function(e,a,n){"use strict";Object.defineProperty(a,"__esModule",{value:!0});var t=n(0),s=n.n(t),o=n(13);a.default=function(e){var a=e.components;return s.a.createElement(o.MDXTag,{name:"wrapper"},s.a.createElement(o.MDXTag,{name:"h1",components:a},"Deterministic styles resolution ðŸ†Ž"),s.a.createElement(o.MDXTag,{name:"p",components:a},"DSS' mission is to provide confidence when authoring CSS. This is done by resolving styles (selectors) in a deterministic way based on the application order of each class name. We think that it is very important to get a predictable result when applying two classes to an element."),s.a.createElement(o.MDXTag,{name:"p",components:a},"Determinism can be achieved thanks to atomic CSS classes. DSS converts declarations to atomic CSS classes. This is done by hashing each property and value and building a class name like the following:"),s.a.createElement(o.MDXTag,{name:"pre",components:a},s.a.createElement(o.MDXTag,{name:"code",components:a,parentName:"pre"},"dss_<hash(property)>-<hash(value)>\n")),s.a.createElement(o.MDXTag,{name:"p",components:a},"For example ",s.a.createElement(o.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"color: red")," is always hashed to:"),s.a.createElement(o.MDXTag,{name:"pre",components:a},s.a.createElement(o.MDXTag,{name:"code",components:a,parentName:"pre"},"dss_rfc3hq-169mlyl\n")),s.a.createElement(o.MDXTag,{name:"p",components:a},"and ",s.a.createElement(o.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"color: green")," to:"),s.a.createElement(o.MDXTag,{name:"pre",components:a},s.a.createElement(o.MDXTag,{name:"code",components:a,parentName:"pre"},"dss_rfc3hq-5rjgso\n")),s.a.createElement(o.MDXTag,{name:"p",components:a},"The first part of these class names is the same: ",s.a.createElement(o.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"dss_rfc3hq-")," and this is information is used to resolve styles."),s.a.createElement(o.MDXTag,{name:"p",components:a},"Given two CSS rules:"),s.a.createElement(o.MDXTag,{name:"pre",components:a},s.a.createElement(o.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:["language-css"]}},".foo {\n  color: red;\n}\n\n.bar {\n  color: green;\n}\n")),s.a.createElement(o.MDXTag,{name:"p",components:a},"DSS compiles them to the following class names:"),s.a.createElement(o.MDXTag,{name:"pre",components:a},s.a.createElement(o.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:["language-JSON"]}},'{\n "foo": [\n    "dss_rfc3hq-169mlyl"\n  ],\n  "bar": [\n    "dss_rfc3hq-5rjgso"\n  ]\n}\n')),s.a.createElement(o.MDXTag,{name:"p",components:a},"Once we have this information we can write a simple ",s.a.createElement(o.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"classNames")," helper that accepts a comma separated list of class references (",s.a.createElement(o.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"foo")," and ",s.a.createElement(o.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"bar")," in the example) and merges them right to left:"),s.a.createElement(o.MDXTag,{name:"pre",components:a},s.a.createElement(o.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:["language-js"]}},"className(styles.foo, styles.bar)\n\n// dss_rfc3hq-5rjgso\n\nclassName(styles.bar, styles.foo)\n\n// dss_rfc3hq-169mlyl\n")),s.a.createElement(o.MDXTag,{name:"p",components:a},"This is similar to how ",s.a.createElement(o.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"Object.assign")," works in JavaScript, except that we are merging lists of atomic CSS classes."))}}},[253]).default}});